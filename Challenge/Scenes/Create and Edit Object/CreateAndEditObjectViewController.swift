//
//  CreateAndEditObjectViewController.swift
//  Challenge
//
//  Created by skrr on 12.07.22.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CreateAndEditObjectDisplayLogic: AnyObject {
	func displayObject(viewModel: CreateAndEditObject.FetchObject.ViewModel) async
	func createObject(viewModel: CreateAndEditObject.CreateObject.ViewModel)
}

class CreateAndEditObjectViewController: UITableViewController, CreateAndEditObjectDisplayLogic {
	var interactor: CreateAndEditObjectBusinessLogic?
	var router: (NSObjectProtocol & CreateAndEditObjectRoutingLogic & CreateAndEditObjectDataPassing)?

	// MARK: Object lifecycle

	init() {
		super.init(nibName: nil, bundle: nil)
		setup()
	}

	/// Not supported. Always `nil`
	required init?(coder: NSCoder) { nil }

	// MARK: Setup

	private func setup() {
		let viewController = self
		let interactor = CreateAndEditObjectInteractor()
		let presenter = CreateAndEditObjectPresenter()
		let router = CreateAndEditObjectRouter()
		viewController.interactor = interactor
		viewController.router = router
		interactor.presenter = presenter
		presenter.viewController = viewController
		router.viewController = viewController
		router.dataStore = interactor
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "ObjectCell")
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "EditCell")
		setNavigationBar()
	}

	// MARK: Routing

	func saveObject() {
		Task {
			await interactor?.saveObject(request: .init(type: object.type, name: object.name, description: object.description, relations: object.relations))
			router?.routeToObjectList()
		}
	}

	func updateObject() {
		Task {
			if let objectId = interactor?.objectToEdit?.id {
				await interactor?.updateObject(request: .init(type: object.type,
															  name: object.name,
															  description: object.description,
															  id: objectId,
															  relations: object.relations))
				router?.routeToObjectList()
			}
		}
	}

	// MARK: Create / Edit object

	var relations: [CreateAndEditObject.FetchObject.ViewModel.DisplayedObject] = []
	var object: CreateAndEditObject.FetchObject.ViewModel.DisplayedObject = .init(type: "", name: "", description: "", relations: [])

	func fetchObject(id: String) {
		let request = CreateAndEditObject.FetchObject.Request(id: id)
		Task {
			await interactor?.fetchObjectForEditing(request: request)
		}
	}

	@MainActor
	func displayObject(viewModel: CreateAndEditObject.FetchObject.ViewModel) async {
		title = viewModel.title
		setNavigationBar(isEditing: true)
		object = viewModel.object

		// TODO: refactor move somewhere else
		for relation in object.relations {
			let object = await interactor?.fetchObject(request: .init(id: relation))
			relations.append(.init(type: object?.type ?? "",
								   name: object?.name ?? "",
								   description: object?.description ?? "",
								   relations: []))
		}
		tableView.reloadData()
	}

	func createObject(viewModel: CreateAndEditObject.CreateObject.ViewModel) {
		title = viewModel.title
		setNavigationBar(isEditing: false)
		tableView.reloadData()
	}

	private func setNavigationBar(isEditing: Bool = false) {
		let saveButton = UIBarButtonItem(systemItem: .save, primaryAction: .init(handler: { [weak self] _ in
			if isEditing {
				self?.updateObject()
			} else {
				self?.saveObject()
			}
		}))

		let addRelationButton = UIBarButtonItem(systemItem: .add, primaryAction: .init(handler: { [weak self] _ in
			if let self = self,
			   let objectId = self.interactor?.objectToEdit?.id {
				Task {
					await self.router?.routeToRelationsSelector(for: objectId)
				}
			}
		}))

		navigationItem.rightBarButtonItems = [saveButton, addRelationButton]
	}

	// MARK: - TableView Data Source

	override func numberOfSections(in tableView: UITableView) -> Int {
		relations.isEmpty ? 1 : 2
	}

	override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		var retVal: Int = 0
		if section == 0 {
			retVal = 3
		} else if section == 1 {
			retVal = relations.count
		}
		return retVal
	}

	override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		var cell = UITableViewCell()
		if indexPath.section == 0 {
			// Object editing
			cell = tableView.dequeueReusableCell(withIdentifier: "EditCell", for: indexPath)
			var config = TextFieldContentConfiguration()
			switch indexPath.row {
			case 0:
				config.text = object.type
				config.placeholder = "Type"
				config.textChanged = { [weak self] type in
					if let type = type {
						self?.object.type = type
					}
				}
			case 1:
				config.text = object.name
				config.placeholder = "Name"
				config.textChanged = { [weak self] name in
					if let name = name {
						self?.object.name = name
					}
				}
			case 2:
				config.text = object.description
				config.placeholder = "Description"
				config.textChanged = { [weak self] description in
					if let description = description {
						self?.object.description = description
					}
				}
			default:
				break
			}
			cell.contentConfiguration = config

		} else if indexPath.section == 1 {
			// Object Relations
			let displayedObject = relations[indexPath.row]
			cell = tableView.dequeueReusableCell(withIdentifier: "ObjectCell", for: indexPath)
			var config = cell.defaultContentConfiguration()

			config.text = "\(displayedObject.type): \(displayedObject.name)"
			config.secondaryText = displayedObject.description
			cell.contentConfiguration = config
		}
		return cell
	}
	override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
		var retVal: String?
		if section == 1 {
			retVal = "Relations"
		}
		return retVal
	}
}
