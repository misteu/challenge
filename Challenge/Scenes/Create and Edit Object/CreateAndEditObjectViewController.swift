//
//  CreateAndEditObjectViewController.swift
//  Challenge
//
//  Created by Michael Steudter on 12.07.22.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Combine

// swiftlint:disable identifier_name
/// Conforming classes can display screens for editing existing objects and creating new objects.
protocol CreateAndEditObjectDisplayLogic: AnyObject {
	/// Prepares view controller for displaying an existing object for editing.
	/// - Parameter viewModel: The view model.
	func displayObject(viewModel: CreateAndEditObject.FetchObject.ViewModel) async
	/// Prepares view controller for creating a new object.
	/// - Parameter viewModel: The view model.
	func createObject(viewModel: CreateAndEditObject.CreateObject.ViewModel) async
}

/// View controller showing editable information of an object and the object's relations to other objects.
final class CreateAndEditObjectViewController: UITableViewController, CreateAndEditObjectDisplayLogic {
	var interactor: CreateAndEditObjectBusinessLogic?
	var router: (NSObjectProtocol & CreateAndEditObjectRoutingLogic)?
	/// Holds all the subscriptions for updates based on CoreData notifications.
	private var cancelBag: Set<AnyCancellable> = []


	/// The currently displayed object.
	private var object: CreateAndEditObject.FetchObject.ViewModel.DisplayedObject = .init(type: "",
																				  name: "",
																				  description: "",
																				  relations: [])
	/// The relations (to other objects) of the currently displayed object.
	private var relations: [CreateAndEditObject.FetchObject.ViewModel.DisplayedObject] = []

	// MARK: - Object lifecycle

	init() {
		super.init(nibName: nil, bundle: nil)
		setup()
	}

	/// Not supported. Always `nil`
	required init?(coder: NSCoder) { nil }

	// MARK: - Setup

	/// Sets up the view controller.
	private func setup() {
		let viewController = self
		let interactor = CreateAndEditObjectInteractor()
		let presenter = CreateAndEditObjectPresenter()
		let router = CreateAndEditObjectRouter()
		viewController.interactor = interactor
		viewController.router = router
		interactor.presenter = presenter
		presenter.viewController = viewController
		router.viewController = viewController
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "ObjectCell")
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "EditCell")
		setNavigationBarButtons()
		setSubscriptions()
	}

	/// Sets subscriptions to CoreData notification.
	private func setSubscriptions() {
		NotificationCenter
			.default
			.publisher(for: Notification.Name.NSManagedObjectContextDidSave, object: nil)
			.receive(on: DispatchQueue.main)
			.sink { [weak self] _ in
				if let self = self,
				   let objectId = self.object.id {
					Task {
						await self.interactor?.fetchObjectForEditing(request: .init(id: objectId))
						self.tableView.reloadData()
					}
				}
			}
			.store(in: &cancelBag)
	}

	// MARK: - Routing

	/// Saves object and routes back to object list.
	func saveObject() {
		Task {
			await interactor?.saveObject(
				request: .init(type: object.type,
							   name: object.name,
							   description: object.description,
							   relations: object.relations)
			)
			router?.routeToObjectList()
		}
	}

	/// Updates object and routes back to object list.
	func updateObject() {
		Task {
			if let objectId = interactor?.objectToEdit?.id {
				await interactor?.updateObject(request: .init(type: object.type,
															  name: object.name,
															  description: object.description,
															  id: objectId,
															  relations: object.relations))
				router?.routeToObjectList()
			}
		}
	}

	/// Fetches object for a given id.
	/// - Parameter id: The object's id.
	func fetchObject(id: String) {
		let request = CreateAndEditObject.FetchObject.Request(id: id)
		Task {
			await interactor?.fetchObjectForEditing(request: request)
		}
	}

	// MARK: - CreateAndEditObjectDisplayLogic

	@MainActor
	func displayObject(viewModel: CreateAndEditObject.FetchObject.ViewModel) async {
		title = viewModel.title
		setNavigationBarButtons(isEditing: true)
		object = viewModel.object
		relations = []

		for relation in object.relations {
			let object = await interactor?.fetchObject(request: .init(id: relation))
			relations.append(.init(type: object?.type ?? "",
								   name: object?.name ?? "",
								   description: object?.description ?? "",
								   relations: [],
								   id: object?.id))
		}
		tableView.reloadData()
	}

	@MainActor
	func createObject(viewModel: CreateAndEditObject.CreateObject.ViewModel) async {
		title = viewModel.title
		setNavigationBarButtons(isEditing: false)
		tableView.reloadData()
	}

	/// Sets buttons in navigation bar based on whether the view controller is editing an existing or creating a new object.
	/// - Parameter isEditing: Set `true` if the an existing object is edited.
	private func setNavigationBarButtons(isEditing: Bool = false) {
		let saveButton = UIBarButtonItem(systemItem: .save, primaryAction: .init(handler: { [weak self] _ in
			if isEditing {
				self?.updateObject()
			} else {
				self?.saveObject()
			}
		}))

		// Add button for adding a relation to another object.
		let addRelationButton = UIBarButtonItem(systemItem: .add, primaryAction: .init(handler: { [weak self] _ in
			if let self = self,
			   let objectId = self.interactor?.objectToEdit?.id {
				Task {
					await self.router?.routeToRelationsSelector(for: objectId)
				}
			}
		}))

		navigationItem.rightBarButtonItems = [saveButton, addRelationButton]
	}

	// MARK: - TableView Data Source

	override func numberOfSections(in tableView: UITableView) -> Int {
		relations.isEmpty ? 1 : 2
	}

	override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		var retVal: Int = 0
		if section == 0 {
			// Objects currently have three different properties (type, name, description)
			// Each of them is represented by an editable row.
			retVal = 3
		} else if section == 1 {
			retVal = relations.count
		}
		return retVal
	}

	// MARK: - Prepare cells

	override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		var cell = UITableViewCell()
		if indexPath.section == 0 {
			// Prepare cells for editing an object's properties.
			cell = tableView.dequeueReusableCell(withIdentifier: "EditCell", for: indexPath)
			var config = TextFieldContentConfiguration()
			switch indexPath.row {
			case 0:
				config.text = object.type
				config.placeholder = "Type"
				config.textChanged = { [weak self] type in
					if let type = type {
						self?.object.type = type
					}
				}
			case 1:
				config.text = object.name
				config.placeholder = "Name"
				config.textChanged = { [weak self] name in
					if let name = name {
						self?.object.name = name
					}
				}
			case 2:
				config.text = object.description
				config.placeholder = "Description"
				config.textChanged = { [weak self] description in
					if let description = description {
						self?.object.description = description
					}
				}
			default:
				break
			}
			cell.contentConfiguration = config

		} else if indexPath.section == 1 {
			// Prepare cells for showing object relations.
			let displayedObject = relations[indexPath.row]
			cell = tableView.dequeueReusableCell(withIdentifier: "ObjectCell", for: indexPath)
			var config = cell.defaultContentConfiguration()

			config.text = "\(displayedObject.type): \(displayedObject.name)"
			config.secondaryText = displayedObject.description
			cell.contentConfiguration = config
		}
		return cell
	}

	override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -> String? {
		var retVal: String?
		if section == 1 {
			retVal = "Relations"
		}
		return retVal
	}

	// MARK: - TableView Delegate

	/// Sets up swipe to delete relation on table view cell.
	override func tableView(
		_ tableView: UITableView,
		trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath
	) -> UISwipeActionsConfiguration? {
		var retVal: UISwipeActionsConfiguration?

		// Only rows of second section (containing relations) should be removable.
		if indexPath.section == 1 {

			let action = UIContextualAction(style: .destructive,
											title: "Remove") { [weak self] _, _, _ in
				if let self = self {
					let relation = self.relations[indexPath.row]
					if let relationsId = relation.id,
					   let objectId = self.object.id {
						var updatedRelations = self.object.relations
						updatedRelations.remove(relationsId)
						let request = CreateAndEditObject.UpdateObject.Request(
							type: self.object.type,
							name: self.object.name,
							description: self.object.description,
							id: objectId,
							relations: updatedRelations
						)
						Task {
							await self.interactor?.updateObject(request: request)
							self.relations.remove(at: indexPath.row)
						}
					}
				}
			}
			retVal = UISwipeActionsConfiguration(actions: [action])
		}
		return retVal
	}
}
