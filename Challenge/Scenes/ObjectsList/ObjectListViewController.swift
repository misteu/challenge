//
//  ObjectListViewController.swift
//  Challenge
//
//  Created by Michael Steudter on 12.07.22.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Combine

protocol ObjectListDisplayLogic: AnyObject {
	func displayFetchedObjects(viewModel: ListObjects.FetchObjects.ViewModel)
	func displayObjectRelationSelector(viewModel: ListObjects.RelationSelector.ViewModel)
}

class ObjectListViewController: UITableViewController, ObjectListDisplayLogic {
	var interactor: ObjectListBusinessLogic?
	var router: (NSObjectProtocol & ObjectListRoutingLogic & ObjectListDataPassing)?

	var cancelBag: Set<AnyCancellable> = []

	// MARK: Object lifecycle

	init() {
		super.init(nibName: nil, bundle: nil)
		setup()
	}

	/// Not supported. Always `nil`
	required init?(coder: NSCoder) { nil }

	// MARK: Setup

	private func setup() {
		let viewController = self
		let interactor = ObjectListInteractor()
		let presenter = ObjectListPresenter()
		let router = ObjectListRouter()
		viewController.interactor = interactor
		viewController.router = router
		interactor.presenter = presenter
		presenter.viewController = viewController
		router.viewController = viewController
		router.dataStore = interactor
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "ObjectCell")
		setNavigationBar()
		setSubscriptions()
	}

	private func setNavigationBar() {
		title = NSLocalizedString("Objects", comment: "Title of the screen showing all the objects.")
		let addButton = UIBarButtonItem(systemItem: .add, primaryAction: .init(handler: { [weak self] _ in
			self?.createObject()
		}))
		navigationItem.rightBarButtonItem = addButton
	}

	private func setSubscriptions() {
		NotificationCenter
			.default
			.publisher(for: Notification.Name.NSManagedObjectContextDidSave, object: nil)
			.receive(on: DispatchQueue.main)
			.sink { [weak self] _ in
				self?.fetchObjects()
			}
			.store(in: &cancelBag)
	}

	// MARK: Routing

	func createObject() {
		Task {
			await router?.routeToCreateObject()
		}
	}

	// MARK: View lifecycle

//	override func viewDidLoad() {
//		super.viewDidLoad()
//		fetchObjects()
//	}

	// MARK: Fetch objects

	var displayedObjects: [ListObjects.DisplayedObject] = []

	func fetchObjects() {
		let request = ListObjects.FetchObjects.Request()
		Task {
			await interactor?.listObjects(request: request)
		}
	}

	func displayFetchedObjects(viewModel: ListObjects.FetchObjects.ViewModel) {
		title = ListObjects.FetchObjects.ViewModel.title
		displayedObjects = viewModel.displayedObjects
		tableView.reloadData()
	}

	func displayObjectRelationSelector(viewModel: ListObjects.RelationSelector.ViewModel) {
		displayedObjects = viewModel.displayedObjects
		title = ListObjects.RelationSelector.ViewModel.title
		tableView.reloadData()
	}


	// MARK: - TableView Data Source & Delegate

	override func numberOfSections(in tableView: UITableView) -> Int {
		1
	}

	override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		displayedObjects.count
	}

	override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		let displayedObject = displayedObjects[indexPath.row]
		let cell = tableView.dequeueReusableCell(withIdentifier: "ObjectCell", for: indexPath)
		var config = cell.defaultContentConfiguration()

		config.text = "\(displayedObject.type): \(displayedObject.name)"
		config.secondaryText = displayedObject.description
		cell.contentConfiguration = config

		// Check if object list is showing all objects or used as relation selector.
		if title == ListObjects.FetchObjects.ViewModel.title {
			cell.accessoryType = .disclosureIndicator
		} else {
			cell.accessoryType = .none
		}
		return cell
	}

	override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		if let displayedObjectsId = displayedObjects[indexPath.row].id {

			// Check if object list is showing all objects or used as relation selector.
			if title == ListObjects.FetchObjects.ViewModel.title {
				Task {
					await router?.routeToEditObject(id: displayedObjectsId)
				}
			} else if let editedObjectsId = interactor?.selectedObjectId {
				Task {
					var object = await interactor?.fetchObject(request: .init(id: editedObjectsId))
					object?.relations.insert(displayedObjectsId)
					await interactor?.addObjectRelation(request: .init(object: object))
					navigationController?.popViewController(animated: true)
				}
			}
		}
	}

	override func tableView(
		_ tableView: UITableView,
		trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath
	) -> UISwipeActionsConfiguration? {
		let action = UIContextualAction(style: .destructive,
										title: "Remove") { _, _, _ in
			if let displayedObjectsId = self.displayedObjects[indexPath.row].id {
				Task {
					await self.interactor?.deleteObject(request: .init(id: displayedObjectsId))
				}
			}
		}
		return UISwipeActionsConfiguration(actions: [action])
	}
}
