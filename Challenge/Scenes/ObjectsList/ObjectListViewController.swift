//
//  ObjectListViewController.swift
//  Challenge
//
//  Created by Michael Steudter on 12.07.22.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import Combine

/// Conforming classes can display fetched objects.
protocol ObjectListDisplayLogic: AnyObject {
	/// Prepares view controller for displaying fetched objects.
	func displayFetchedObjects(viewModel: ListObjects.FetchObjects.ViewModel)
	/// Prepares view controller for displaying fetched objects to be selected as object relations.
	func displayObjectRelationSelector(viewModel: ListObjects.RelationSelector.ViewModel)
}

final class ObjectListViewController: UITableViewController, ObjectListDisplayLogic {
	var interactor: ObjectListBusinessLogic?
	var router: (NSObjectProtocol & ObjectListRoutingLogic)?
	/// Search controller for filtering objects.
	let searchController = UISearchController(searchResultsController: nil)
	/// Holds subscriptions for updating UI based on CoreData notifications.
	var cancelBag: Set<AnyCancellable> = []
	/// All the currently displayed objects.
	var displayedObjects: [ListObjects.DisplayedObject] = []

	// MARK: - Object lifecycle

	init() {
		super.init(nibName: nil, bundle: nil)
		setup()
	}

	/// Not supported. Always `nil`
	required init?(coder: NSCoder) { nil }

	// MARK: - Setup

	/// Sets up view controller.
	private func setup() {
		let viewController = self
		let interactor = ObjectListInteractor()
		let presenter = ObjectListPresenter()
		let router = ObjectListRouter()
		viewController.interactor = interactor
		viewController.router = router
		interactor.presenter = presenter
		presenter.viewController = viewController
		router.viewController = viewController
		tableView.register(UITableViewCell.self, forCellReuseIdentifier: "ObjectCell")
		setNavigationBar()
		setSubscriptions()
		setSearch()
	}

	/// Sets up navigation bar and it's right button.
	private func setNavigationBar() {
		title = NSLocalizedString("Objects", comment: "Title of the screen showing all the objects.")
		let addButton = UIBarButtonItem(systemItem: .add, primaryAction: .init(handler: { [weak self] _ in
			self?.createObject()
		}))
		navigationItem.rightBarButtonItem = addButton
	}

	/// Sets up search controller.
	private func setSearch() {
		self.navigationItem.searchController = searchController
		searchController.searchResultsUpdater = self
	}

	/// Sets subscriptions for CoreData notifications.
	private func setSubscriptions() {
		NotificationCenter
			.default
			.publisher(for: Notification.Name.NSManagedObjectContextDidSave, object: nil)
			.receive(on: DispatchQueue.main)
			.sink { [weak self] _ in
				self?.fetchObjects()
			}
			.store(in: &cancelBag)
	}

	// MARK: - Routing

	/// Routes to object creation screen.
	func createObject() {
		Task {
			await router?.routeToCreateObject()
		}
	}

	// MARK: - Fetch objects

	/// Fetches and lists objects.
	func fetchObjects() {
		let request = ListObjects.FetchObjects.Request()
		Task {
			await interactor?.listObjects(request: request)
		}
	}

	// MARK: - ObjectListDisplayLogic

	func displayFetchedObjects(viewModel: ListObjects.FetchObjects.ViewModel) {
		title = ListObjects.FetchObjects.ViewModel.title
		displayedObjects = viewModel.displayedObjects
		tableView.reloadData()
	}

	func displayObjectRelationSelector(viewModel: ListObjects.RelationSelector.ViewModel) {
		displayedObjects = viewModel.displayedObjects
		displayedObjects.removeAll(where: { $0.id == interactor?.selectedObjectId })
		title = ListObjects.RelationSelector.ViewModel.title
		navigationItem.rightBarButtonItem = nil
		tableView.reloadData()
	}

	// MARK: - TableView Data Source

	override func numberOfSections(in tableView: UITableView) -> Int {
		1
	}

	override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
		displayedObjects.count
	}

	override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
		let displayedObject = displayedObjects[indexPath.row]
		let cell = tableView.dequeueReusableCell(withIdentifier: "ObjectCell", for: indexPath)
		var config = cell.defaultContentConfiguration()

		// Configure cell with given object data.
		config.text = "\(displayedObject.type): \(displayedObject.name)"
		config.secondaryText = displayedObject.description
		cell.contentConfiguration = config

		// When list is showing all objects, disclosure indicator is set to indicate navigation to object editing.
		if title == ListObjects.FetchObjects.ViewModel.title {
			cell.accessoryType = .disclosureIndicator
		} else {
			cell.accessoryType = .none
		}
		return cell
	}

	// MARK: - TableView Delegate

	override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
		if let displayedObjectsId = displayedObjects[indexPath.row].id {

			// View controller is used for showing existing objects: Navigating to object's edit screen.
			if title == ListObjects.FetchObjects.ViewModel.title {
				Task {
					await router?.routeToEditObject(id: displayedObjectsId)
				}
			// View controller is used for adding relation to object: Update relation and navigate back to edit screen.
			} else if let editedObjectsId = interactor?.selectedObjectId {
				Task {
					var object = await interactor?.fetchObject(request: .init(id: editedObjectsId))
					object?.relations.insert(displayedObjectsId)
					await interactor?.addObjectRelation(request: .init(object: object))
					navigationController?.popViewController(animated: true)
				}
			}
		}
	}

	// MARK: - Swipe to delete object

	override func tableView(
		_ tableView: UITableView,
		trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath
	) -> UISwipeActionsConfiguration? {
		let action = UIContextualAction(style: .destructive,
										title: "Remove") { _, _, _ in
			if let displayedObjectsId = self.displayedObjects[indexPath.row].id {
				Task {
					await self.interactor?.deleteObject(request: .init(id: displayedObjectsId))
				}
			}
		}
		return UISwipeActionsConfiguration(actions: [action])
	}
}

extension ObjectListViewController: UISearchResultsUpdating {

	func updateSearchResults(for searchController: UISearchController) {

		// TODO: Searching might be refactored to search via CoreData fetch queries instead of filtering the data source.
		if let searchText = searchController.searchBar.text, !searchText.isEmpty {
			displayedObjects = displayedObjects.filter { object in
				object.name.localizedCaseInsensitiveContains(searchText) ||
				object.type.localizedCaseInsensitiveContains(searchText) ||
				object.description.localizedCaseInsensitiveContains(searchText)
			}
		} else {
			Task {
				// List all objects, exclude currently edited object from search results.
				await interactor?.listObjects(request: .init(excludedId: interactor?.selectedObjectId))
			}
		}
		self.tableView.reloadData()
	}
}
